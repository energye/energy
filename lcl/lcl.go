//----------------------------------------
// The code is automatically generated by the generate-tool.
// Copyright © yanghy. All Rights Reserved.
//
// Licensed under Apache License 2.0
//
//----------------------------------------

package lcl

import (
	"github.com/energye/energy/v2/api"
	"github.com/energye/energy/v2/types"
	"math"
	"unsafe"
)

type unsafePointer = unsafe.Pointer

func MathRound(AValue float64) int64 {
	if AValue >= 0 {
		return int64(math.Trunc(AValue + 0.5))
	} else {
		return int64(math.Trunc(AValue - 0.5))
	}
}

func MulDiv(nNumber, nNumerator, nDenominator int32) int32 {
	if nDenominator == 0 {
		return -1
	} else if nNumerator == nDenominator {
		return nNumber
	} else {
		return int32(MathRound(float64(nNumber) * float64(nNumerator) / float64(nDenominator)))
	}
}

// sysCallGetTextBuf
//
//	 *string(PChar)指定缓冲区大小获取字符串值
//	 GetTextBuf(Buffer *string, BufSize int32)
//
//	 参数
//		 index: 导入表索引
//		 obj: 对象指针
//		 buffer: 返回字符串缓冲区
//		 bufSize: 返回字符串范围
func sysCallGetTextBuf(index int, obj uintptr, buffer *string, bufSize int32) uintptr {
	if buffer == nil || bufSize == 0 {
		return 0
	}
	bufferPtr := make([]uint8, bufSize+1)
	sLen := api.LCL().SysCallN(index, obj, uintptr(unsafe.Pointer(&bufferPtr[0])), uintptr(bufSize))
	if sLen > 0 {
		*buffer = string(bufferPtr[:sLen])
	}
	return sLen
}

// sysCallBufferRead
//
//		获取指定大小缓冲区内字节数据
//	 (count int32) (int32, []byte)
//
//	 参数
//		 index: 导入表索引
//		 obj: 对象指针
//		 count: 缓冲区内字节数
func sysCallBufferRead(index int, obj uintptr, count int32) (uintptr, []byte) {
	if count <= 0 {
		return 0, nil
	}
	buffer := make([]byte, count)
	r := api.LCL().SysCallN(index, obj, uintptr(unsafe.Pointer(&buffer[0])), uintptr(count))
	return r, buffer
}

// sysCallBufferRead
//
//	 (buffer []byte) (int32)
//
//	 参数
//		 index: 导入表索引
//		 obj: 对象指针
//		 buffer: 字节数据
func sysCallBufferWrite(index int, obj uintptr, buffer []byte) uintptr {
	return api.LCL().SysCallN(index, obj, uintptr(unsafe.Pointer(&buffer[0])), uintptr(len(buffer)))
}

// sysCallPoint
func sysCallPoint(index int, obj uintptr, points []types.TPoint, otherArgs ...uintptr) uintptr {
	args := []uintptr{obj, uintptr(unsafe.Pointer(&points[0])), uintptr(len(points))}
	args = append(args, otherArgs...)
	return api.LCL().SysCallN(index, args...)
}

// sysCallRect
func sysCallRect(index int, obj uintptr, rects []types.TRect, otherArgs ...uintptr) uintptr {
	args := []uintptr{obj, uintptr(unsafe.Pointer(&rects[0])), uintptr(len(rects))}
	args = append(args, otherArgs...)
	return api.LCL().SysCallN(index, args...)
}

// TStatStg
type TStatStg struct {
	PwcsName          string //PWideChar
	DwType            types.DWORD
	CbSize            int64
	Mtime             string // TFileTime, 转换TDateTime: FileTimeToDateTime 函数, 转换string: DateTimeToStr 函数
	Ctime             string // TFileTime
	Atime             string // TFileTime
	GrfMode           types.DWORD
	GrfLocksSupported types.DWORD
	Clsid             string // TCLSID=TGuid, 转换string: TGuid.ToString()
	GrfStateBits      types.DWORD
	Reserved          types.DWORD
}

// TStatStg
type tStatStgPtr struct {
	PwcsName          uintptr // string //PWideChar
	DwType            uintptr // types.DWORD
	CbSize            uintptr // int64
	Mtime             uintptr // string // TFileTime, 转换TDateTime: FileTimeToDateTime 函数, 转换string: DateTimeToStr 函数
	Ctime             uintptr // string // TFileTime
	Atime             uintptr // string // TFileTime
	GrfMode           uintptr // types.DWORD
	GrfLocksSupported uintptr // types.DWORD
	Clsid             uintptr // string // TCLSID=TGuid, 转换string: TGuid.ToString()
	GrfStateBits      uintptr // types.DWORD
	Reserved          uintptr // types.DWORD
}
